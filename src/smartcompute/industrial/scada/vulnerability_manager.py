#!/usr/bin/env python3
"""
SmartCompute Industrial Vulnerability Manager - GestiÃ³n Avanzada de Vulnerabilidades por UbicaciÃ³n

CaracterÃ­sticas:
- Mapeo de vulnerabilidades por ubicaciÃ³n fÃ­sica en planta
- PriorizaciÃ³n por sector crÃ­tico y impacto operacional
- IntegraciÃ³n con CVE database y threat intelligence
- AnÃ¡lisis de superficie de ataque por zona
- GestiÃ³n de remediaciÃ³n con workflow por ubicaciÃ³n
- Dashboard interactivo con plano de planta
- CorrelaciÃ³n con variables industriales
- Compliance con marcos de ciberseguridad industrial

Sectores Industriales:
- Ãrea de ProducciÃ³n (LÃ­neas 1-5)
- Sala ElÃ©ctrica Principal y Secundaria
- Sistema de Control Central (SCADA/DCS)
- Ãrea de Almacenamiento (FrÃ­o/Ambiente/QuÃ­micos)
- Laboratorio de Calidad
- Oficinas Administrativas
- Sistemas de Tratamiento de Agua
- Ãrea de Mantenimiento

Author: SmartCompute Team
Version: 2.0.0 Vulnerability Manager
Date: 2025-09-19
"""

import asyncio
import json
import sqlite3
import requests
import uuid
import math
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any, Union
from pathlib import Path
from dataclasses import dataclass, asdict, field
from enum import Enum
import logging
import hashlib
import numpy as np
from collections import defaultdict
import xml.etree.ElementTree as ET

class VulnerabilitySeverity(Enum):
    """Severidad de vulnerabilidades con scoring CVSS"""
    CRITICAL = "critical"     # 9.0-10.0
    HIGH = "high"            # 7.0-8.9
    MEDIUM = "medium"        # 4.0-6.9
    LOW = "low"             # 0.1-3.9
    NONE = "none"           # 0.0

class PlantSector(Enum):
    """Sectores de la planta industrial"""
    PRODUCTION_LINE_1 = "production_line_1"
    PRODUCTION_LINE_2 = "production_line_2"
    PRODUCTION_LINE_3 = "production_line_3"
    MAIN_ELECTRICAL_ROOM = "main_electrical_room"
    SECONDARY_ELECTRICAL = "secondary_electrical"
    CONTROL_ROOM = "control_room"
    SCADA_SYSTEM = "scada_system"
    COLD_STORAGE = "cold_storage"
    AMBIENT_STORAGE = "ambient_storage"
    CHEMICAL_STORAGE = "chemical_storage"
    QUALITY_LAB = "quality_lab"
    ADMIN_OFFICES = "admin_offices"
    WATER_TREATMENT = "water_treatment"
    MAINTENANCE_AREA = "maintenance_area"
    PERIMETER_SECURITY = "perimeter_security"

class CriticalityLevel(Enum):
    """Nivel de criticidad del sector"""
    SAFETY_CRITICAL = "safety_critical"      # Sistemas de seguridad
    MISSION_CRITICAL = "mission_critical"    # ProducciÃ³n principal
    BUSINESS_CRITICAL = "business_critical"  # Sistemas de negocio
    SUPPORT = "support"                      # Sistemas de soporte
    ADMINISTRATIVE = "administrative"        # Sistemas administrativos

class RemediationStatus(Enum):
    """Estado de remediaciÃ³n"""
    IDENTIFIED = "identified"
    ASSIGNED = "assigned"
    IN_PROGRESS = "in_progress"
    TESTING = "testing"
    COMPLETED = "completed"
    DEFERRED = "deferred"
    ACCEPTED_RISK = "accepted_risk"

@dataclass
class PlantCoordinate:
    """Coordenadas fÃ­sicas en el plano de planta"""
    x: float  # Coordenada X en metros
    y: float  # Coordenada Y en metros
    z: float = 0.0  # Nivel/piso (0=planta baja)
    building: str = "main"
    floor: str = "ground"

@dataclass
class PlantZone:
    """Zona fÃ­sica de la planta"""
    zone_id: str
    name: str
    sector: PlantSector
    criticality: CriticalityLevel
    coordinates: PlantCoordinate
    area_m2: float
    equipment_count: int
    personnel_count: int
    access_level: str
    emergency_procedures: List[str] = field(default_factory=list)
    safety_systems: List[str] = field(default_factory=list)

@dataclass
class IndustrialAsset:
    """Activo industrial con ubicaciÃ³n fÃ­sica"""
    asset_id: str
    name: str
    asset_type: str
    manufacturer: str
    model: str
    firmware_version: str
    ip_address: Optional[str]
    mac_address: Optional[str]
    zone_id: str
    coordinates: PlantCoordinate
    protocols: List[str] = field(default_factory=list)
    services: List[Dict] = field(default_factory=list)
    last_scan: Optional[datetime] = None
    online: bool = True

@dataclass
class Vulnerability:
    """Vulnerabilidad especÃ­fica con contexto industrial"""
    vuln_id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: float
    cvss_vector: str
    affected_assets: List[str]
    discovery_date: datetime
    source: str
    exploit_available: bool = False
    exploit_complexity: str = "unknown"
    threat_actor_interest: str = "unknown"

    # Context industrial
    industrial_impact: Dict[str, Any] = field(default_factory=dict)
    safety_impact: bool = False
    production_impact: bool = False
    environmental_impact: bool = False

    # UbicaciÃ³n y priorizaciÃ³n
    affected_zones: List[str] = field(default_factory=list)
    business_priority: int = 0  # 1-10
    technical_priority: int = 0  # 1-10
    operational_impact_hours: float = 0.0

    # RemediaciÃ³n
    remediation_status: RemediationStatus = RemediationStatus.IDENTIFIED
    assigned_to: Optional[str] = None
    remediation_plan: Optional[Dict] = None
    estimated_effort_hours: float = 0.0
    target_resolution_date: Optional[datetime] = None

@dataclass
class ThreatIntelligence:
    """InformaciÃ³n de amenazas especÃ­ficas para ICS/SCADA"""
    threat_id: str
    name: str
    threat_actors: List[str]
    ttps: List[str]  # Tactics, Techniques, Procedures
    targeted_sectors: List[str]
    targeted_protocols: List[str]
    first_seen: datetime
    last_updated: datetime
    iocs: List[Dict] = field(default_factory=list)  # Indicators of Compromise
    confidence: float = 0.0  # 0.0-1.0

class IndustrialVulnerabilityManager:
    """Gestor principal de vulnerabilidades industriales"""

    def __init__(self):
        self.logger = self.setup_logging()
        self.db_path = Path(__file__).parent / "industrial_vulnerabilities.db"

        # Estado del sistema
        self.plant_zones = {}
        self.industrial_assets = {}
        self.vulnerabilities = {}
        self.threat_intel = {}

        # ConfiguraciÃ³n de priorizaciÃ³n
        self.sector_priority_weights = self._load_sector_weights()
        self.cvss_industrial_modifiers = self._load_cvss_modifiers()

        self.init_database()
        self.load_plant_configuration()

        self.logger.info("ğŸ›¡ï¸ Industrial Vulnerability Manager initialized")

    def setup_logging(self) -> logging.Logger:
        """Configurar sistema de logging"""
        logger = logging.getLogger('IndustrialVulnManager')
        logger.setLevel(logging.INFO)

        handler = logging.FileHandler('smartcompute_vulnerability_manager.log')
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)

        return logger

    def init_database(self):
        """Inicializar base de datos de vulnerabilidades"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        # Tabla de zonas de planta
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS plant_zones (
                zone_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                sector TEXT NOT NULL,
                criticality TEXT NOT NULL,
                coordinates_x REAL,
                coordinates_y REAL,
                coordinates_z REAL,
                building TEXT,
                floor TEXT,
                area_m2 REAL,
                equipment_count INTEGER,
                personnel_count INTEGER,
                access_level TEXT,
                emergency_procedures TEXT,
                safety_systems TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')

        # Tabla de activos industriales
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS industrial_assets (
                asset_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                asset_type TEXT NOT NULL,
                manufacturer TEXT,
                model TEXT,
                firmware_version TEXT,
                ip_address TEXT,
                mac_address TEXT,
                zone_id TEXT NOT NULL,
                coordinates_x REAL,
                coordinates_y REAL,
                coordinates_z REAL,
                protocols TEXT,
                services TEXT,
                last_scan TIMESTAMP,
                online BOOLEAN DEFAULT TRUE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (zone_id) REFERENCES plant_zones (zone_id)
            )
        ''')

        # Tabla de vulnerabilidades
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                vuln_id TEXT PRIMARY KEY,
                cve_id TEXT,
                title TEXT NOT NULL,
                description TEXT,
                severity TEXT NOT NULL,
                cvss_score REAL NOT NULL,
                cvss_vector TEXT,
                affected_assets TEXT,
                discovery_date TIMESTAMP NOT NULL,
                source TEXT,
                exploit_available BOOLEAN DEFAULT FALSE,
                exploit_complexity TEXT,
                threat_actor_interest TEXT,
                industrial_impact TEXT,
                safety_impact BOOLEAN DEFAULT FALSE,
                production_impact BOOLEAN DEFAULT FALSE,
                environmental_impact BOOLEAN DEFAULT FALSE,
                affected_zones TEXT,
                business_priority INTEGER DEFAULT 0,
                technical_priority INTEGER DEFAULT 0,
                operational_impact_hours REAL DEFAULT 0.0,
                remediation_status TEXT DEFAULT 'identified',
                assigned_to TEXT,
                remediation_plan TEXT,
                estimated_effort_hours REAL DEFAULT 0.0,
                target_resolution_date TIMESTAMP,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')

        # Tabla de inteligencia de amenazas
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS threat_intelligence (
                threat_id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                threat_actors TEXT,
                ttps TEXT,
                targeted_sectors TEXT,
                targeted_protocols TEXT,
                iocs TEXT,
                first_seen TIMESTAMP,
                last_updated TIMESTAMP,
                confidence REAL DEFAULT 0.0,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')

        # Tabla de remediaciÃ³n con tracking
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS remediation_tracking (
                tracking_id TEXT PRIMARY KEY,
                vuln_id TEXT NOT NULL,
                action_type TEXT NOT NULL,
                action_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                performed_by TEXT,
                details TEXT,
                success BOOLEAN,
                evidence_path TEXT,
                FOREIGN KEY (vuln_id) REFERENCES vulnerabilities (vuln_id)
            )
        ''')

        # Ãndices para rendimiento
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_vulns_severity ON vulnerabilities(severity)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_vulns_zones ON vulnerabilities(affected_zones)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_assets_zone ON industrial_assets(zone_id)')
        cursor.execute('CREATE INDEX IF NOT EXISTS idx_vulns_status ON vulnerabilities(remediation_status)')

        conn.commit()
        conn.close()

    def load_plant_configuration(self):
        """Cargar configuraciÃ³n de planta y zonas"""
        # ConfiguraciÃ³n de ejemplo de planta industrial
        plant_zones_config = [
            PlantZone(
                zone_id="prod_line_1",
                name="Production Line 1 - Main Assembly",
                sector=PlantSector.PRODUCTION_LINE_1,
                criticality=CriticalityLevel.MISSION_CRITICAL,
                coordinates=PlantCoordinate(x=50.0, y=30.0, z=0.0),
                area_m2=500.0,
                equipment_count=15,
                personnel_count=8,
                access_level="Authorized Personnel",
                emergency_procedures=["Emergency Stop", "Fire Suppression", "Evacuation Route A"],
                safety_systems=["Light Curtains", "Emergency Stops", "Lockout/Tagout"]
            ),
            PlantZone(
                zone_id="control_room_main",
                name="Main Control Room - SCADA Center",
                sector=PlantSector.CONTROL_ROOM,
                criticality=CriticalityLevel.SAFETY_CRITICAL,
                coordinates=PlantCoordinate(x=10.0, y=50.0, z=0.0),
                area_m2=100.0,
                equipment_count=25,
                personnel_count=3,
                access_level="Control Room Badge Required",
                emergency_procedures=["Manual Override", "Backup Control", "Emergency Communication"],
                safety_systems=["UPS Backup", "Fire Suppression", "Access Control"]
            ),
            PlantZone(
                zone_id="electrical_main",
                name="Main Electrical Room - 11kV Switchgear",
                sector=PlantSector.MAIN_ELECTRICAL_ROOM,
                criticality=CriticalityLevel.SAFETY_CRITICAL,
                coordinates=PlantCoordinate(x=5.0, y=5.0, z=0.0),
                area_m2=80.0,
                equipment_count=12,
                personnel_count=0,  # Normalmente desatendida
                access_level="Electrical Engineer Only",
                emergency_procedures=["Arc Flash Response", "Electrical Lockout", "Emergency Power Off"],
                safety_systems=["Arc Flash Detection", "SF6 Gas Monitoring", "Emergency Lighting"]
            ),
            PlantZone(
                zone_id="cold_storage_main",
                name="Main Cold Storage - Dairy Products",
                sector=PlantSector.COLD_STORAGE,
                criticality=CriticalityLevel.BUSINESS_CRITICAL,
                coordinates=PlantCoordinate(x=80.0, y=60.0, z=0.0),
                area_m2=300.0,
                equipment_count=8,
                personnel_count=2,
                access_level="Cold Storage Certified",
                emergency_procedures=["Temperature Alarm Response", "Product Quarantine", "Cold Room Rescue"],
                safety_systems=["Temperature Monitoring", "Emergency Release", "Backup Refrigeration"]
            ),
            PlantZone(
                zone_id="water_treatment",
                name="Water Treatment Plant",
                sector=PlantSector.WATER_TREATMENT,
                criticality=CriticalityLevel.BUSINESS_CRITICAL,
                coordinates=PlantCoordinate(x=20.0, y=80.0, z=0.0),
                area_m2=200.0,
                equipment_count=10,
                personnel_count=1,
                access_level="Water Treatment Specialist",
                emergency_procedures=["Chemical Spill Response", "Water Quality Alert", "System Shutdown"],
                safety_systems=["Chemical Detection", "Emergency Shower", "Ventilation System"]
            )
        ]

        for zone in plant_zones_config:
            self.plant_zones[zone.zone_id] = zone
            self.save_plant_zone(zone)

        # Activos industriales de ejemplo
        industrial_assets_config = [
            IndustrialAsset(
                asset_id="plc_main_prod_1",
                name="Production Line 1 Main PLC",
                asset_type="PLC",
                manufacturer="Siemens",
                model="S7-1515",
                firmware_version="V2.8.3",
                ip_address="192.168.1.10",
                mac_address="00:1B:1B:12:34:56",
                zone_id="prod_line_1",
                coordinates=PlantCoordinate(x=45.0, y=25.0, z=0.0),
                protocols=["S7comm", "PROFINET", "Modbus TCP"],
                services=[
                    {"name": "S7comm", "port": 102, "version": "V2.8"},
                    {"name": "HTTP", "port": 80, "version": "1.1"},
                    {"name": "SNMP", "port": 161, "version": "v2c"}
                ]
            ),
            IndustrialAsset(
                asset_id="hmi_control_main",
                name="Main Control Room HMI",
                asset_type="HMI",
                manufacturer="Wonderware",
                model="InTouch 2023",
                firmware_version="23.1.0.142",
                ip_address="192.168.1.20",
                mac_address="00:50:56:AB:CD:EF",
                zone_id="control_room_main",
                coordinates=PlantCoordinate(x=8.0, y=48.0, z=0.0),
                protocols=["OPC-UA", "Ethernet/IP", "HTTP/HTTPS"],
                services=[
                    {"name": "OPC-UA", "port": 4840, "version": "1.04"},
                    {"name": "HTTPS", "port": 443, "version": "TLS 1.2"},
                    {"name": "RDP", "port": 3389, "version": "10.0"}
                ]
            ),
            IndustrialAsset(
                asset_id="ups_electrical_main",
                name="Main Electrical UPS System",
                asset_type="UPS",
                manufacturer="Schneider Electric",
                model="Galaxy VX 500kVA",
                firmware_version="01.03.0004",
                ip_address="192.168.2.5",
                mac_address="00:80:C2:12:34:56",
                zone_id="electrical_main",
                coordinates=PlantCoordinate(x=3.0, y=8.0, z=0.0),
                protocols=["Modbus TCP", "SNMP", "HTTP"],
                services=[
                    {"name": "Modbus TCP", "port": 502, "version": "1.1b3"},
                    {"name": "SNMP", "port": 161, "version": "v3"},
                    {"name": "HTTP", "port": 80, "version": "1.1"}
                ]
            ),
            IndustrialAsset(
                asset_id="temp_monitor_cold_1",
                name="Cold Storage Temperature Monitor 1",
                asset_type="Temperature Controller",
                manufacturer="Omron",
                model="E5CC-QX2ASM-800",
                firmware_version="1.2",
                ip_address="192.168.3.15",
                mac_address="00:00:CD:12:34:56",
                zone_id="cold_storage_main",
                coordinates=PlantCoordinate(x=78.0, y=58.0, z=0.0),
                protocols=["FINS", "Modbus RTU"],
                services=[
                    {"name": "FINS", "port": 9600, "version": "V4.0"},
                    {"name": "HTTP", "port": 80, "version": "1.0"}
                ]
            ),
            IndustrialAsset(
                asset_id="scada_water_treatment",
                name="Water Treatment SCADA Server",
                asset_type="SCADA Server",
                manufacturer="Emerson",
                model="DeltaV Pro Plus",
                firmware_version="14.3.1",
                ip_address="192.168.4.10",
                mac_address="00:A0:C9:14:C8:29",
                zone_id="water_treatment",
                coordinates=PlantCoordinate(x=18.0, y=82.0, z=0.0),
                protocols=["DeltaV", "OPC-DA", "OPC-UA", "Modbus TCP"],
                services=[
                    {"name": "OPC-UA", "port": 4840, "version": "1.04"},
                    {"name": "OPC-DA", "port": 135, "version": "3.0"},
                    {"name": "SQL Server", "port": 1433, "version": "2019"}
                ]
            )
        ]

        for asset in industrial_assets_config:
            self.industrial_assets[asset.asset_id] = asset
            self.save_industrial_asset(asset)

        self.logger.info(f"âœ… Loaded {len(plant_zones_config)} plant zones and {len(industrial_assets_config)} industrial assets")

    def _load_sector_weights(self) -> Dict[PlantSector, float]:
        """Cargar pesos de prioridad por sector"""
        return {
            PlantSector.SCADA_SYSTEM: 10.0,
            PlantSector.CONTROL_ROOM: 9.5,
            PlantSector.MAIN_ELECTRICAL_ROOM: 9.0,
            PlantSector.PRODUCTION_LINE_1: 8.5,
            PlantSector.PRODUCTION_LINE_2: 8.0,
            PlantSector.PRODUCTION_LINE_3: 7.5,
            PlantSector.WATER_TREATMENT: 7.0,
            PlantSector.COLD_STORAGE: 6.5,
            PlantSector.SECONDARY_ELECTRICAL: 6.0,
            PlantSector.CHEMICAL_STORAGE: 5.5,
            PlantSector.QUALITY_LAB: 5.0,
            PlantSector.AMBIENT_STORAGE: 4.0,
            PlantSector.MAINTENANCE_AREA: 3.5,
            PlantSector.PERIMETER_SECURITY: 3.0,
            PlantSector.ADMIN_OFFICES: 2.0
        }

    def _load_cvss_modifiers(self) -> Dict[str, float]:
        """Cargar modificadores CVSS para contexto industrial"""
        return {
            "safety_impact": 2.0,
            "production_impact": 1.5,
            "environmental_impact": 1.8,
            "remote_exploit": 1.3,
            "no_user_interaction": 1.2,
            "high_complexity": 0.8,
            "authentication_required": 0.7
        }

    def save_plant_zone(self, zone: PlantZone):
        """Guardar zona de planta en base de datos"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            INSERT OR REPLACE INTO plant_zones
            (zone_id, name, sector, criticality, coordinates_x, coordinates_y, coordinates_z,
             building, floor, area_m2, equipment_count, personnel_count, access_level,
             emergency_procedures, safety_systems)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            zone.zone_id, zone.name, zone.sector.value, zone.criticality.value,
            zone.coordinates.x, zone.coordinates.y, zone.coordinates.z,
            zone.coordinates.building, zone.coordinates.floor,
            zone.area_m2, zone.equipment_count, zone.personnel_count,
            zone.access_level,
            json.dumps(zone.emergency_procedures),
            json.dumps(zone.safety_systems)
        ))

        conn.commit()
        conn.close()

    def save_industrial_asset(self, asset: IndustrialAsset):
        """Guardar activo industrial en base de datos"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            INSERT OR REPLACE INTO industrial_assets
            (asset_id, name, asset_type, manufacturer, model, firmware_version,
             ip_address, mac_address, zone_id, coordinates_x, coordinates_y, coordinates_z,
             protocols, services, last_scan, online)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            asset.asset_id, asset.name, asset.asset_type, asset.manufacturer,
            asset.model, asset.firmware_version, asset.ip_address, asset.mac_address,
            asset.zone_id, asset.coordinates.x, asset.coordinates.y, asset.coordinates.z,
            json.dumps(asset.protocols), json.dumps(asset.services),
            asset.last_scan, asset.online
        ))

        conn.commit()
        conn.close()

    def discover_vulnerabilities_by_zone(self, zone_id: str) -> List[Vulnerability]:
        """Descubrir vulnerabilidades especÃ­ficas por zona"""
        if zone_id not in self.plant_zones:
            return []

        zone = self.plant_zones[zone_id]
        zone_assets = [asset for asset in self.industrial_assets.values()
                      if asset.zone_id == zone_id]

        discovered_vulnerabilities = []

        # Simular descubrimiento de vulnerabilidades por activo
        for asset in zone_assets:
            asset_vulns = self._scan_asset_vulnerabilities(asset)
            for vuln in asset_vulns:
                vuln.affected_zones = [zone_id]
                # Calcular priorizaciÃ³n contextual
                vuln.business_priority = self._calculate_business_priority(vuln, zone)
                vuln.technical_priority = self._calculate_technical_priority(vuln, asset)
                vuln.operational_impact_hours = self._estimate_operational_impact(vuln, zone)

                discovered_vulnerabilities.append(vuln)
                self.vulnerabilities[vuln.vuln_id] = vuln

        self.logger.info(f"ğŸ” Discovered {len(discovered_vulnerabilities)} vulnerabilities in zone {zone_id}")
        return discovered_vulnerabilities

    def _scan_asset_vulnerabilities(self, asset: IndustrialAsset) -> List[Vulnerability]:
        """Escanear vulnerabilidades en activo especÃ­fico"""
        vulnerabilities = []

        # Vulnerabilidades de ejemplo basadas en tipo de activo y servicios
        if asset.asset_type == "PLC":
            vulnerabilities.extend(self._get_plc_vulnerabilities(asset))
        elif asset.asset_type == "HMI":
            vulnerabilities.extend(self._get_hmi_vulnerabilities(asset))
        elif asset.asset_type == "UPS":
            vulnerabilities.extend(self._get_ups_vulnerabilities(asset))
        elif asset.asset_type == "SCADA Server":
            vulnerabilities.extend(self._get_scada_vulnerabilities(asset))
        elif asset.asset_type == "Temperature Controller":
            vulnerabilities.extend(self._get_controller_vulnerabilities(asset))

        return vulnerabilities

    def _get_plc_vulnerabilities(self, asset: IndustrialAsset) -> List[Vulnerability]:
        """Obtener vulnerabilidades especÃ­ficas de PLC"""
        vulns = []

        if asset.manufacturer == "Siemens":
            # CVE real de Siemens S7
            vuln = Vulnerability(
                vuln_id=f"vuln_{uuid.uuid4().hex[:8]}",
                cve_id="CVE-2022-43464",
                title="Siemens SIMATIC S7-1500 Memory Protection Bypass",
                description="A vulnerability in Siemens SIMATIC S7-1500 CPU allows attackers to bypass memory protection mechanisms",
                severity=VulnerabilitySeverity.HIGH,
                cvss_score=7.5,
                cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N",
                affected_assets=[asset.asset_id],
                discovery_date=datetime.now(),
                source="Siemens Security Advisory",
                exploit_available=True,
                exploit_complexity="medium",
                threat_actor_interest="high",
                industrial_impact={
                    "process_disruption": True,
                    "unauthorized_control": True,
                    "data_manipulation": True
                },
                safety_impact=True,
                production_impact=True
            )
            vulns.append(vuln)

            # ConfiguraciÃ³n insegura
            config_vuln = Vulnerability(
                vuln_id=f"vuln_{uuid.uuid4().hex[:8]}",
                cve_id=None,
                title="PLC Default Credentials in Use",
                description=f"Default credentials detected on PLC {asset.name}",
                severity=VulnerabilitySeverity.CRITICAL,
                cvss_score=9.1,
                cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                affected_assets=[asset.asset_id],
                discovery_date=datetime.now(),
                source="Configuration Scan",
                exploit_available=True,
                exploit_complexity="low",
                threat_actor_interest="very_high",
                industrial_impact={
                    "full_control": True,
                    "program_modification": True,
                    "safety_bypass": True
                },
                safety_impact=True,
                production_impact=True,
                environmental_impact=True
            )
            vulns.append(config_vuln)

        return vulns

    def _get_hmi_vulnerabilities(self, asset: IndustrialAsset) -> List[Vulnerability]:
        """Obtener vulnerabilidades especÃ­ficas de HMI"""
        vulns = []

        # Vulnerabilidad de autenticaciÃ³n dÃ©bil
        auth_vuln = Vulnerability(
            vuln_id=f"vuln_{uuid.uuid4().hex[:8]}",
            cve_id="CVE-2023-28771",
            title="HMI Weak Authentication Mechanism",
            description="Weak authentication allows unauthorized access to HMI system",
            severity=VulnerabilitySeverity.HIGH,
            cvss_score=8.2,
            cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:L/A:N",
            affected_assets=[asset.asset_id],
            discovery_date=datetime.now(),
            source="Security Scan",
            exploit_available=True,
            exploit_complexity="low",
            industrial_impact={
                "unauthorized_monitoring": True,
                "alarm_manipulation": True,
                "setpoint_changes": True
            },
            production_impact=True
        )
        vulns.append(auth_vuln)

        return vulns

    def _get_ups_vulnerabilities(self, asset: IndustrialAsset) -> List[Vulnerability]:
        """Obtener vulnerabilidades especÃ­ficas de UPS"""
        vulns = []

        # SNMP v2c sin autenticaciÃ³n
        snmp_vuln = Vulnerability(
            vuln_id=f"vuln_{uuid.uuid4().hex[:8]}",
            cve_id=None,
            title="UPS SNMP v2c Weak Authentication",
            description="SNMP v2c community strings provide insufficient authentication",
            severity=VulnerabilitySeverity.MEDIUM,
            cvss_score=6.5,
            cvss_vector="CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N",
            affected_assets=[asset.asset_id],
            discovery_date=datetime.now(),
            source="Network Scan",
            industrial_impact={
                "power_monitoring_access": True,
                "configuration_exposure": True
            },
            safety_impact=True  # UPS crÃ­tico para seguridad
        )
        vulns.append(snmp_vuln)

        return vulns

    def _get_scada_vulnerabilities(self, asset: IndustrialAsset) -> List[Vulnerability]:
        """Obtener vulnerabilidades especÃ­ficas de SCADA"""
        vulns = []

        # Vulnerabilidad crÃ­tica en servidor SCADA
        scada_vuln = Vulnerability(
            vuln_id=f"vuln_{uuid.uuid4().hex[:8]}",
            cve_id="CVE-2023-27997",
            title="SCADA Server SQL Injection",
            description="SQL injection vulnerability in SCADA historian database",
            severity=VulnerabilitySeverity.CRITICAL,
            cvss_score=9.8,
            cvss_vector="CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
            affected_assets=[asset.asset_id],
            discovery_date=datetime.now(),
            source="Application Security Test",
            exploit_available=True,
            exploit_complexity="low",
            threat_actor_interest="very_high",
            industrial_impact={
                "historical_data_manipulation": True,
                "control_system_compromise": True,
                "process_data_theft": True
            },
            safety_impact=True,
            production_impact=True,
            environmental_impact=True
        )
        vulns.append(scada_vuln)

        return vulns

    def _get_controller_vulnerabilities(self, asset: IndustrialAsset) -> List[Vulnerability]:
        """Obtener vulnerabilidades especÃ­ficas de controladores"""
        vulns = []

        # Firmware desactualizado
        firmware_vuln = Vulnerability(
            vuln_id=f"vuln_{uuid.uuid4().hex[:8]}",
            cve_id=None,
            title="Outdated Controller Firmware",
            description="Temperature controller running outdated firmware with known vulnerabilities",
            severity=VulnerabilitySeverity.MEDIUM,
            cvss_score=5.4,
            cvss_vector="CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N",
            affected_assets=[asset.asset_id],
            discovery_date=datetime.now(),
            source="Firmware Scan",
            industrial_impact={
                "temperature_control_bypass": True,
                "false_readings": True
            },
            production_impact=True  # Afecta control de temperatura crÃ­tico
        )
        vulns.append(firmware_vuln)

        return vulns

    def _calculate_business_priority(self, vuln: Vulnerability, zone: PlantZone) -> int:
        """Calcular prioridad de negocio (1-10)"""
        base_priority = 5

        # Factor de criticidad del sector
        sector_weight = self.sector_priority_weights.get(zone.sector, 1.0)
        priority_adjustment = (sector_weight - 5.0) / 2.0  # Normalizar a +/-2.5

        # Factor de impacto en seguridad
        if vuln.safety_impact:
            priority_adjustment += 2.0

        # Factor de impacto en producciÃ³n
        if vuln.production_impact:
            priority_adjustment += 1.5

        # Factor de impacto ambiental
        if vuln.environmental_impact:
            priority_adjustment += 1.0

        # Factor de disponibilidad de exploit
        if vuln.exploit_available:
            priority_adjustment += 1.0

        final_priority = max(1, min(10, int(base_priority + priority_adjustment)))
        return final_priority

    def _calculate_technical_priority(self, vuln: Vulnerability, asset: IndustrialAsset) -> int:
        """Calcular prioridad tÃ©cnica (1-10)"""
        base_priority = int(vuln.cvss_score)

        # Ajustes por contexto industrial
        if vuln.exploit_complexity == "low":
            base_priority = min(10, base_priority + 1)

        # Protocolos expuestos
        exposed_protocols = len(asset.protocols)
        if exposed_protocols > 3:
            base_priority = min(10, base_priority + 1)

        # Servicios de red expuestos
        network_services = len([s for s in asset.services if s.get('port', 0) > 0])
        if network_services > 2:
            base_priority = min(10, base_priority + 1)

        return max(1, min(10, base_priority))

    def _estimate_operational_impact(self, vuln: Vulnerability, zone: PlantZone) -> float:
        """Estimar impacto operacional en horas"""
        base_impact = 0.0

        # Impacto base por criticidad del sector
        if zone.criticality == CriticalityLevel.SAFETY_CRITICAL:
            base_impact = 24.0  # 24 horas de impacto potencial
        elif zone.criticality == CriticalityLevel.MISSION_CRITICAL:
            base_impact = 12.0
        elif zone.criticality == CriticalityLevel.BUSINESS_CRITICAL:
            base_impact = 6.0
        else:
            base_impact = 2.0

        # Multiplicar por severidad de vulnerabilidad
        severity_multiplier = {
            VulnerabilitySeverity.CRITICAL: 2.0,
            VulnerabilitySeverity.HIGH: 1.5,
            VulnerabilitySeverity.MEDIUM: 1.0,
            VulnerabilitySeverity.LOW: 0.5
        }

        impact_hours = base_impact * severity_multiplier.get(vuln.severity, 1.0)

        # Ajuste por tipo de impacto
        if vuln.safety_impact:
            impact_hours *= 1.5

        return round(impact_hours, 2)

    async def scan_all_zones(self) -> Dict[str, List[Vulnerability]]:
        """Escanear vulnerabilidades en todas las zonas"""
        self.logger.info("ğŸ” Starting comprehensive vulnerability scan of all zones...")

        zone_vulnerabilities = {}
        scan_tasks = []

        for zone_id in self.plant_zones.keys():
            task = asyncio.create_task(
                self._scan_zone_async(zone_id)
            )
            scan_tasks.append((zone_id, task))

        # Ejecutar escaneos en paralelo
        for zone_id, task in scan_tasks:
            try:
                vulnerabilities = await task
                zone_vulnerabilities[zone_id] = vulnerabilities

                # Guardar en base de datos
                for vuln in vulnerabilities:
                    await self.save_vulnerability(vuln)

            except Exception as e:
                self.logger.error(f"Error scanning zone {zone_id}: {e}")
                zone_vulnerabilities[zone_id] = []

        total_vulns = sum(len(vulns) for vulns in zone_vulnerabilities.values())
        self.logger.info(f"âœ… Scan completed: {total_vulns} vulnerabilities found across {len(zone_vulnerabilities)} zones")

        return zone_vulnerabilities

    async def _scan_zone_async(self, zone_id: str) -> List[Vulnerability]:
        """Escanear zona especÃ­fica de manera asÃ­ncrona"""
        # Simular tiempo de escaneo
        await asyncio.sleep(0.5)
        return self.discover_vulnerabilities_by_zone(zone_id)

    async def save_vulnerability(self, vuln: Vulnerability):
        """Guardar vulnerabilidad en base de datos"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()

        cursor.execute('''
            INSERT OR REPLACE INTO vulnerabilities
            (vuln_id, cve_id, title, description, severity, cvss_score, cvss_vector,
             affected_assets, discovery_date, source, exploit_available, exploit_complexity,
             threat_actor_interest, industrial_impact, safety_impact, production_impact,
             environmental_impact, affected_zones, business_priority, technical_priority,
             operational_impact_hours, remediation_status, assigned_to, remediation_plan,
             estimated_effort_hours, target_resolution_date, updated_at)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (
            vuln.vuln_id, vuln.cve_id, vuln.title, vuln.description,
            vuln.severity.value, vuln.cvss_score, vuln.cvss_vector,
            json.dumps(vuln.affected_assets), vuln.discovery_date, vuln.source,
            vuln.exploit_available, vuln.exploit_complexity, vuln.threat_actor_interest,
            json.dumps(vuln.industrial_impact), vuln.safety_impact, vuln.production_impact,
            vuln.environmental_impact, json.dumps(vuln.affected_zones),
            vuln.business_priority, vuln.technical_priority, vuln.operational_impact_hours,
            vuln.remediation_status.value, vuln.assigned_to,
            json.dumps(vuln.remediation_plan, default=str) if vuln.remediation_plan else None,
            vuln.estimated_effort_hours, vuln.target_resolution_date,
            datetime.now()
        ))

        conn.commit()
        conn.close()

    def generate_vulnerability_map(self) -> Dict:
        """Generar mapa de vulnerabilidades por ubicaciÃ³n"""
        vulnerability_map = {
            "plant_layout": {
                "dimensions": {"width": 100.0, "height": 90.0, "units": "meters"},
                "zones": [],
                "vulnerabilities": [],
                "risk_heatmap": []
            },
            "summary": {
                "total_vulnerabilities": len(self.vulnerabilities),
                "critical_vulnerabilities": len([v for v in self.vulnerabilities.values()
                                               if v.severity == VulnerabilitySeverity.CRITICAL]),
                "zones_affected": len(set().union(*[v.affected_zones for v in self.vulnerabilities.values()])),
                "highest_risk_zone": None,
                "remediation_backlog_hours": sum(v.estimated_effort_hours for v in self.vulnerabilities.values())
            }
        }

        # Mapear zonas con informaciÃ³n de riesgo
        for zone_id, zone in self.plant_zones.items():
            zone_vulns = [v for v in self.vulnerabilities.values() if zone_id in v.affected_zones]

            zone_risk_score = sum(v.business_priority * v.technical_priority for v in zone_vulns) / max(len(zone_vulns), 1)

            zone_info = {
                "zone_id": zone_id,
                "name": zone.name,
                "coordinates": asdict(zone.coordinates),
                "area_m2": zone.area_m2,
                "criticality": zone.criticality.value,
                "vulnerability_count": len(zone_vulns),
                "risk_score": round(zone_risk_score, 2),
                "vulnerabilities": [v.vuln_id for v in zone_vulns]
            }

            vulnerability_map["plant_layout"]["zones"].append(zone_info)

            # Generar puntos de calor para mapa
            if zone_vulns:
                heat_point = {
                    "x": zone.coordinates.x,
                    "y": zone.coordinates.y,
                    "intensity": min(100, zone_risk_score * 10),
                    "vulnerability_count": len(zone_vulns),
                    "zone_name": zone.name
                }
                vulnerability_map["plant_layout"]["risk_heatmap"].append(heat_point)

        # Determinar zona de mayor riesgo
        if vulnerability_map["plant_layout"]["zones"]:
            highest_risk_zone = max(vulnerability_map["plant_layout"]["zones"],
                                  key=lambda z: z["risk_score"])
            vulnerability_map["summary"]["highest_risk_zone"] = highest_risk_zone["name"]

        # Mapear vulnerabilidades individuales
        for vuln in self.vulnerabilities.values():
            vuln_info = {
                "vuln_id": vuln.vuln_id,
                "title": vuln.title,
                "severity": vuln.severity.value,
                "cvss_score": vuln.cvss_score,
                "affected_zones": vuln.affected_zones,
                "business_priority": vuln.business_priority,
                "technical_priority": vuln.technical_priority,
                "remediation_status": vuln.remediation_status.value,
                "coordinates": []
            }

            # Agregar coordenadas de activos afectados
            for asset_id in vuln.affected_assets:
                if asset_id in self.industrial_assets:
                    asset = self.industrial_assets[asset_id]
                    vuln_info["coordinates"].append({
                        "x": asset.coordinates.x,
                        "y": asset.coordinates.y,
                        "asset_name": asset.name
                    })

            vulnerability_map["plant_layout"]["vulnerabilities"].append(vuln_info)

        return vulnerability_map

    def get_vulnerability_dashboard_data(self) -> Dict:
        """Obtener datos para dashboard de vulnerabilidades"""
        dashboard_data = {
            "summary_metrics": self._calculate_summary_metrics(),
            "severity_distribution": self._get_severity_distribution(),
            "zone_risk_analysis": self._get_zone_risk_analysis(),
            "remediation_progress": self._get_remediation_progress(),
            "threat_landscape": self._get_threat_landscape(),
            "compliance_status": self._get_compliance_status()
        }

        return dashboard_data

    def _calculate_summary_metrics(self) -> Dict:
        """Calcular mÃ©tricas de resumen"""
        total_vulns = len(self.vulnerabilities)
        if total_vulns == 0:
            return {"total": 0, "risk_score": 0, "zones_affected": 0, "assets_affected": 0}

        # Risk score promedio ponderado
        risk_scores = [v.business_priority * v.technical_priority for v in self.vulnerabilities.values()]
        avg_risk_score = sum(risk_scores) / len(risk_scores)

        affected_zones = set().union(*[v.affected_zones for v in self.vulnerabilities.values()])
        affected_assets = set().union(*[v.affected_assets for v in self.vulnerabilities.values()])

        return {
            "total_vulnerabilities": total_vulns,
            "average_risk_score": round(avg_risk_score, 2),
            "zones_affected": len(affected_zones),
            "assets_affected": len(affected_assets),
            "critical_count": len([v for v in self.vulnerabilities.values()
                                 if v.severity == VulnerabilitySeverity.CRITICAL]),
            "high_count": len([v for v in self.vulnerabilities.values()
                             if v.severity == VulnerabilitySeverity.HIGH]),
            "safety_impact_count": len([v for v in self.vulnerabilities.values() if v.safety_impact]),
            "production_impact_count": len([v for v in self.vulnerabilities.values() if v.production_impact])
        }

    def _get_severity_distribution(self) -> Dict:
        """Obtener distribuciÃ³n por severidad"""
        severity_counts = defaultdict(int)
        for vuln in self.vulnerabilities.values():
            severity_counts[vuln.severity.value] += 1

        return dict(severity_counts)

    def _get_zone_risk_analysis(self) -> List[Dict]:
        """Obtener anÃ¡lisis de riesgo por zona"""
        zone_analysis = []

        for zone_id, zone in self.plant_zones.items():
            zone_vulns = [v for v in self.vulnerabilities.values() if zone_id in v.affected_zones]

            if zone_vulns:
                risk_score = sum(v.business_priority * v.technical_priority for v in zone_vulns) / len(zone_vulns)

                analysis = {
                    "zone_id": zone_id,
                    "zone_name": zone.name,
                    "criticality": zone.criticality.value,
                    "vulnerability_count": len(zone_vulns),
                    "risk_score": round(risk_score, 2),
                    "critical_vulns": len([v for v in zone_vulns if v.severity == VulnerabilitySeverity.CRITICAL]),
                    "high_vulns": len([v for v in zone_vulns if v.severity == VulnerabilitySeverity.HIGH]),
                    "estimated_impact_hours": sum(v.operational_impact_hours for v in zone_vulns)
                }

                zone_analysis.append(analysis)

        return sorted(zone_analysis, key=lambda z: z["risk_score"], reverse=True)

    def _get_remediation_progress(self) -> Dict:
        """Obtener progreso de remediaciÃ³n"""
        status_counts = defaultdict(int)
        total_effort = 0.0
        completed_effort = 0.0

        for vuln in self.vulnerabilities.values():
            status_counts[vuln.remediation_status.value] += 1
            total_effort += vuln.estimated_effort_hours

            if vuln.remediation_status == RemediationStatus.COMPLETED:
                completed_effort += vuln.estimated_effort_hours

        progress_percentage = (completed_effort / total_effort * 100) if total_effort > 0 else 0

        return {
            "status_distribution": dict(status_counts),
            "total_effort_hours": round(total_effort, 2),
            "completed_effort_hours": round(completed_effort, 2),
            "progress_percentage": round(progress_percentage, 2),
            "overdue_count": len([v for v in self.vulnerabilities.values()
                                if v.target_resolution_date and v.target_resolution_date < datetime.now()])
        }

    def _get_threat_landscape(self) -> Dict:
        """Obtener panorama de amenazas"""
        return {
            "exploit_available_count": len([v for v in self.vulnerabilities.values() if v.exploit_available]),
            "high_actor_interest": len([v for v in self.vulnerabilities.values()
                                      if v.threat_actor_interest in ["high", "very_high"]]),
            "industrial_specific": len([v for v in self.vulnerabilities.values()
                                      if v.industrial_impact]),
            "remote_exploitable": len([v for v in self.vulnerabilities.values()
                                     if "AV:N" in v.cvss_vector])
        }

    def _get_compliance_status(self) -> Dict:
        """Obtener estado de cumplimiento"""
        # Simular chequeos de compliance
        return {
            "iec_62443": {"compliant": 85, "total": 100, "percentage": 85.0},
            "nist_csf": {"compliant": 78, "total": 90, "percentage": 86.7},
            "iso_27001": {"compliant": 92, "total": 114, "percentage": 80.7}
        }


async def main():
    """FunciÃ³n principal"""
    print("ğŸ›¡ï¸ SmartCompute Industrial Vulnerability Manager")
    print("=" * 60)

    manager = IndustrialVulnerabilityManager()

    try:
        # Escanear todas las zonas
        zone_vulnerabilities = await manager.scan_all_zones()

        # Mostrar resumen
        print(f"\nğŸ“Š Vulnerability Scan Results:")
        for zone_id, vulns in zone_vulnerabilities.items():
            zone_name = manager.plant_zones[zone_id].name
            critical_count = len([v for v in vulns if v.severity == VulnerabilitySeverity.CRITICAL])
            high_count = len([v for v in vulns if v.severity == VulnerabilitySeverity.HIGH])

            print(f"  ğŸ­ {zone_name}: {len(vulns)} vulnerabilities")
            if critical_count > 0:
                print(f"    ğŸš¨ Critical: {critical_count}")
            if high_count > 0:
                print(f"    âš ï¸  High: {high_count}")

        # Generar mapa de vulnerabilidades
        vuln_map = manager.generate_vulnerability_map()
        print(f"\nğŸ—ºï¸  Vulnerability Map Generated:")
        print(f"  Total Zones: {len(vuln_map['plant_layout']['zones'])}")
        print(f"  Highest Risk Zone: {vuln_map['summary']['highest_risk_zone']}")
        print(f"  Total Risk Points: {len(vuln_map['plant_layout']['risk_heatmap'])}")

        # Dashboard data
        dashboard = manager.get_vulnerability_dashboard_data()
        print(f"\nğŸ“ˆ Dashboard Metrics:")
        print(f"  Average Risk Score: {dashboard['summary_metrics']['average_risk_score']}")
        print(f"  Safety Impact Count: {dashboard['summary_metrics']['safety_impact_count']}")
        print(f"  Production Impact Count: {dashboard['summary_metrics']['production_impact_count']}")

    except KeyboardInterrupt:
        print("\nğŸ›‘ Stopping vulnerability manager...")
    except Exception as e:
        print(f"âŒ Critical error: {e}")


if __name__ == "__main__":
    asyncio.run(main())