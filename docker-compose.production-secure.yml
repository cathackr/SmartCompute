# SmartCompute Production Architecture with Complete Security
# TLS, mTLS, Rate Limiting, Circuit Breakers, and Defense in Depth

version: '3.8'

networks:
  public:
    driver: bridge
    ipam:
      config:
        - subnet: 172.18.1.0/24
  api:
    driver: bridge  
    ipam:
      config:
        - subnet: 172.18.2.0/24
  internal:
    driver: bridge
    internal: true
    ipam:
      config:
        - subnet: 172.18.3.0/24
  isolated:
    driver: bridge
    internal: true
    ipam:
      config:
        - subnet: 172.18.4.0/24
  database:
    driver: bridge
    internal: true
    ipam:
      config:
        - subnet: 172.18.5.0/24
  monitoring:
    driver: bridge
    internal: true
    ipam:
      config:
        - subnet: 172.18.6.0/24

volumes:
  postgres_data:
    driver: local
  redis_data:
    driver: local
  vault_data:
    driver: local
  nginx_cache:
    driver: local
  tls_certs:
    driver: local

secrets:
  db_password:
    external: true
  redis_password:
    external: true
  jwt_secret:
    external: true
  payment_webhook_secret:
    external: true
  vault_root_token:
    external: true

services:
  # Certificate Generation (Init Container)
  cert-generator:
    build:
      context: .
      dockerfile: security/Dockerfile.cert-generator
    container_name: smartcompute-cert-generator
    volumes:
      - tls_certs:/certs
      - ./security/tls:/app/security/tls
    environment:
      - CERT_COUNTRY=US
      - CERT_STATE=California
      - CERT_CITY=San Francisco
      - CERT_ORG=SmartCompute
      - CERT_ORG_UNIT=Security
    command: /app/security/tls/generate-certs.sh
    networks:
      - internal

  # NGINX Reverse Proxy with TLS Termination
  nginx:
    image: nginx:alpine
    container_name: smartcompute-nginx
    ports:
      - "80:80"
      - "443:443"
      - "9443:9443"   # Internal core service
      - "9444:9444"   # Payment service
    volumes:
      - ./nginx/production-secure.conf:/etc/nginx/nginx.conf:ro
      - tls_certs:/etc/nginx/certs:ro
      - nginx_cache:/var/cache/nginx
      - ./nginx/dhparam.pem:/etc/nginx/certs/dhparam.pem:ro
    networks:
      - public
      - api
      - internal
      - isolated
    depends_on:
      - cert-generator
      - api-service
      - dashboard
      - smartcompute-core
      - payment-service
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.3'
    sysctls:
      - net.core.somaxconn=65535
      - net.ipv4.ip_local_port_range=1024 65535
      - net.ipv4.tcp_tw_reuse=1

  # Web Dashboard (Frontend)
  dashboard:
    build: 
      context: .
      dockerfile: services/dashboard/Dockerfile.secure
    container_name: smartcompute-dashboard
    networks:
      - api
    environment:
      - NODE_ENV=production
      - API_BASE_URL=https://api.smartcompute.com
      - TLS_ENABLED=true
      - CERTS_DIR=/app/certs
    volumes:
      - tls_certs:/app/certs:ro
    depends_on:
      - cert-generator
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "-k", "https://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'

  # Public API Service with Security Integration
  api-service:
    build: 
      context: .
      dockerfile: services/api/Dockerfile.secure
      args:
        - SECURITY_ENABLED=true
    container_name: smartcompute-api
    networks:
      - api
      - internal
    environment:
      - DATABASE_URL=postgresql://smartcompute:${DB_PASSWORD}@postgres:5432/smartcompute
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
      - CORE_SERVICE_URL=https://smartcompute-core:9443
      - JWT_SECRET_FILE=/run/secrets/jwt_secret
      - RATE_LIMIT_REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/1
      - TLS_ENABLED=true
      - MTLS_REQUIRED=false
      - CERTS_DIR=/app/certs
      - SERVICE_NAME=smartcompute-api
      - ENVIRONMENT=production
      - CIRCUIT_BREAKER_ENABLED=true
      - RATE_LIMITING_ENABLED=true
    volumes:
      - tls_certs:/app/certs:ro
    secrets:
      - jwt_secret
      - db_password
      - redis_password
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      smartcompute-core:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "-k", "https://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '1.0'
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp:noexec,nosuid,size=100m

  # SmartCompute Core Engine (Internal with mTLS)
  smartcompute-core:
    build:
      context: .
      dockerfile: services/core/Dockerfile.secure
      args:
        - SECURITY_ENABLED=true
    container_name: smartcompute-core
    networks:
      - internal
      - database
    environment:
      - DATABASE_URL=postgresql://smartcompute:${DB_PASSWORD}@postgres:5432/smartcompute
      - REDIS_URL=redis://:${REDIS_PASSWORD}@redis:6379/2
      - LOG_LEVEL=INFO
      - ENABLE_DOCS=false
      - TLS_ENABLED=true
      - MTLS_REQUIRED=true
      - CERTS_DIR=/app/certs
      - SERVICE_NAME=smartcompute-core
      - ENVIRONMENT=production
      - CIRCUIT_BREAKER_ENABLED=true
      - RATE_LIMITING_ENABLED=true
    volumes:
      - tls_certs:/app/certs:ro
    secrets:
      - db_password
      - redis_password
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "-k", "--cert", "/app/certs/client/core-client-cert.pem", "--key", "/app/certs/client/core-client-key.pem", "https://localhost:9000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '2.0'
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp:noexec,nosuid,size=200m

  # Payment Gateway Service (Maximum Security)
  payment-service:
    build:
      context: .
      dockerfile: services/payment/Dockerfile.secure
      args:
        - SECURITY_ENABLED=true
    container_name: smartcompute-payment
    networks:
      - isolated
    environment:
      - VAULT_ADDR=https://vault:8200
      - VAULT_TOKEN_FILE=/run/secrets/vault_root_token
      - WEBHOOK_SECRET_FILE=/run/secrets/payment_webhook_secret
      - DATABASE_URL=postgresql://payment_user:${PAYMENT_DB_PASSWORD}@postgres:5432/smartcompute_payments
      - TLS_ENABLED=true
      - MTLS_REQUIRED=true
      - CERTS_DIR=/app/certs
      - SERVICE_NAME=smartcompute-payment
      - ENVIRONMENT=production
      - CIRCUIT_BREAKER_ENABLED=true
      - CIRCUIT_BREAKER_FAILURE_THRESHOLD=3
      - CIRCUIT_BREAKER_RECOVERY_TIMEOUT=120
      - RATE_LIMITING_ENABLED=true
    volumes:
      - tls_certs:/app/certs:ro
    secrets:
      - vault_root_token
      - payment_webhook_secret
    depends_on:
      cert-generator:
        condition: service_completed_successfully
      vault:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "-k", "--cert", "/app/certs/client/payment-client-cert.pem", "--key", "/app/certs/client/payment-client-key.pem", "https://localhost:9001/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
    security_opt:
      - no-new-privileges:true
      - apparmor:docker-default
    read_only: true
    tmpfs:
      - /tmp:noexec,nosuid,size=50m
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE

  # PostgreSQL Database with TLS
  postgres:
    image: postgres:15-alpine
    container_name: smartcompute-postgres
    networks:
      - database
      - isolated
    environment:
      - POSTGRES_DB=smartcompute
      - POSTGRES_USER=smartcompute
      - POSTGRES_PASSWORD_FILE=/run/secrets/db_password
      - POSTGRES_MULTIPLE_DATABASES=smartcompute_payments
      - POSTGRES_INITDB_ARGS=--auth-local=trust --auth-host=scram-sha-256
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - tls_certs:/etc/ssl/certs:ro
      - ./scripts/create-multiple-databases.sh:/docker-entrypoint-initdb.d/create-multiple-databases.sh:ro
      - ./scripts/init-payment-user.sql:/docker-entrypoint-initdb.d/init-payment-user.sql:ro
      - ./postgres/postgresql.conf:/etc/postgresql/postgresql.conf:ro
      - ./postgres/pg_hba.conf:/etc/postgresql/pg_hba.conf:ro
    secrets:
      - db_password
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U smartcompute -d smartcompute"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 30s
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'
    security_opt:
      - no-new-privileges:true
    tmpfs:
      - /tmp:noexec,nosuid,size=100m

  # Redis with TLS and Password Authentication
  redis:
    image: redis:7-alpine
    container_name: smartcompute-redis
    networks:
      - internal
      - api
    command: >
      redis-server
      --requirepass ${REDIS_PASSWORD}
      --appendonly yes
      --appendfsync everysec
      --maxmemory 1g
      --maxmemory-policy allkeys-lru
      --databases 16
      --tcp-keepalive 300
      --timeout 30
      --tcp-backlog 511
      --bind 0.0.0.0
    volumes:
      - redis_data:/data
      - tls_certs:/tls:ro
    secrets:
      - redis_password
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "--pass", "${REDIS_PASSWORD}", "ping"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
    security_opt:
      - no-new-privileges:true

  # HashiCorp Vault with TLS
  vault:
    image: vault:latest
    container_name: smartcompute-vault
    networks:
      - isolated
    environment:
      - VAULT_DEV_ROOT_TOKEN_ID_FILE=/run/secrets/vault_root_token
      - VAULT_DEV_LISTEN_ADDRESS=0.0.0.0:8200
      - VAULT_API_ADDR=https://vault:8200
      - VAULT_CLUSTER_ADDR=https://vault:8201
    volumes:
      - vault_data:/vault/data
      - tls_certs:/vault/certs:ro
      - ./vault/config-secure.hcl:/vault/config/config.hcl:ro
    secrets:
      - vault_root_token
    cap_add:
      - IPC_LOCK
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "vault", "status"]
      interval: 30s
      timeout: 10s
      retries: 3
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
    security_opt:
      - no-new-privileges:true

  # Security Scanner (Optional)
  security-scanner:
    build:
      context: .
      dockerfile: security/Dockerfile.scanner
    container_name: smartcompute-security-scanner
    networks:
      - internal
    environment:
      - SCAN_TARGETS=smartcompute-api:8000,smartcompute-core:9000,smartcompute-payment:9001
      - SCAN_INTERVAL=3600
      - TLS_VERIFY=true
    volumes:
      - tls_certs:/certs:ro
      - ./security/scanner-config.yaml:/app/config.yaml:ro
    restart: unless-stopped
    profiles:
      - security-scanning
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.2'

  # Log Aggregation (ELK Stack or similar)
  log-aggregator:
    image: fluentbit/fluent-bit:latest
    container_name: smartcompute-logs
    networks:
      - internal
      - monitoring
    volumes:
      - /var/lib/docker/containers:/var/lib/docker/containers:ro
      - /var/log:/var/log:ro
      - ./logging/fluent-bit-secure.conf:/fluent-bit/etc/fluent-bit.conf:ro
    depends_on:
      - cert-generator
    restart: unless-stopped
    profiles:
      - logging
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.2'

# Health check for the entire stack
x-healthcheck-depends: &healthcheck-depends
  depends_on:
    postgres:
      condition: service_healthy
    redis:
      condition: service_healthy
    vault:
      condition: service_healthy